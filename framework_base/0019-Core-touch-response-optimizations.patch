From e4ab7e5a70de35270d447b44da11bbd5e464662e Mon Sep 17 00:00:00 2001
From: Astridxx <muratkozan350@gmail.com>
Date: Tue, 6 Feb 2024 11:30:59 +0300
Subject: [PATCH] core: touch response optimizations

---
 core/java/android/view/Choreographer.java     | 77 +++++++++++++++++-
 .../java/android/view/InputEventReceiver.java | 15 ++++
 core/java/android/widget/AbsListView.java     | 81 ++++++++++++++++++-
 core/jni/android_view_InputEventReceiver.cpp  | 32 +++++++-
 4 files changed, 200 insertions(+), 5 deletions(-)

diff --git a/core/java/android/view/Choreographer.java b/core/java/android/view/Choreographer.java
index cc68ddd9e211f..00d62f90c41bf 100644
--- a/core/java/android/view/Choreographer.java
+++ b/core/java/android/view/Choreographer.java
@@ -87,6 +87,7 @@ public final class Choreographer {
 
     // Prints debug messages about jank which was detected (low volume).
     private static final boolean DEBUG_JANK = false;
+    private static final boolean OPTS_INPUT = true;
 
     // Prints debug messages about every frame and callback registered (high volume).
     private static final boolean DEBUG_FRAMES = false;
@@ -154,6 +155,11 @@ protected Choreographer initialValue() {
     private static final int MSG_DO_SCHEDULE_VSYNC = 1;
     private static final int MSG_DO_SCHEDULE_CALLBACK = 2;
 
+    private static final int MOTION_EVENT_ACTION_DOWN = 0;
+    private static final int MOTION_EVENT_ACTION_UP = 1;
+    private static final int MOTION_EVENT_ACTION_MOVE = 2;
+    private static final int MOTION_EVENT_ACTION_CANCEL = 3;
+
     // All frame callbacks posted by applications have this token or VSYNC_CALLBACK_TOKEN.
     private static final Object FRAME_CALLBACK_TOKEN = new Object() {
         public String toString() { return "FRAME_CALLBACK_TOKEN"; }
@@ -198,6 +204,13 @@ public String toString() {
     private DisplayEventReceiver.VsyncEventData mLastVsyncEventData =
             new DisplayEventReceiver.VsyncEventData();
 
+    private int mTouchMoveNum = -1;
+    private int mMotionEventType = -1;
+    private boolean mConsumedMove = false;
+    private boolean mConsumedDown = false;
+    private boolean mIsVsyncScheduled = false;
+    private long mLastTouchOptTimeNanos = 0;
+    private boolean mIsDoFrameProcessing = false;
     /**
      * Contains information about the current frame for jank-tracking,
      * mainly timings of key events along with a bit of metadata about
@@ -312,6 +325,16 @@ public static Choreographer getSfInstance() {
         return sSfThreadInstance.get();
     }
 
+    /**
+     * {@hide}
+     */
+    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
+        synchronized(this) {
+            mTouchMoveNum = touchMoveNum;
+            mMotionEventType = motionEventType;
+        }
+    }
+
     /**
      * @return The Choreographer of the main thread, if it exists, or {@code null} otherwise.
      * @hide
@@ -677,7 +700,55 @@ public long getLastFrameTimeNanos() {
     private void scheduleFrameLocked(long now) {
         if (!mFrameScheduled) {
             mFrameScheduled = true;
-            if (USE_VSYNC) {
+            if (OPTS_INPUT) {
+                if (!mIsVsyncScheduled) {
+                    long curr = System.nanoTime();
+                    boolean skipFlag = curr - mLastTouchOptTimeNanos < mFrameIntervalNanos;
+                    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleFrameLocked-mMotionEventType:"
+                                     + mMotionEventType + " mTouchMoveNum:"+ mTouchMoveNum 
+                                     + " mConsumedDown:" + mConsumedDown
+                                     + " mConsumedMove:" + mConsumedMove
+                                     + " mIsDoFrameProcessing:" + mIsDoFrameProcessing
+                                     + " skip:" + skipFlag
+                                     + " diff:" + (curr - mLastTouchOptTimeNanos));
+                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
+                    synchronized(this) {
+                        switch(mMotionEventType) {
+                            case MOTION_EVENT_ACTION_DOWN:
+                                mConsumedMove = false;
+                                if (!mConsumedDown && !skipFlag && !mIsDoFrameProcessing) {
+                                    Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                    msg.setAsynchronous(true);
+                                    mHandler.sendMessageAtFrontOfQueue(msg);
+                                    mLastTouchOptTimeNanos = System.nanoTime();
+                                    mConsumedDown = true;
+                                    return;
+                                }
+                                break;
+                            case MOTION_EVENT_ACTION_MOVE:
+                                mConsumedDown = false;
+                                //if ((mTouchMoveNum == 1) && !mConsumedMove && !skipFlag) {
+                                if (!mConsumedMove && !skipFlag && !mIsDoFrameProcessing) {
+                                    Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                    msg.setAsynchronous(true);
+                                    mHandler.sendMessageAtFrontOfQueue(msg);
+                                    mLastTouchOptTimeNanos = System.nanoTime();
+                                    mConsumedMove = true;
+                                    return;
+                                }
+                                break;
+                            case MOTION_EVENT_ACTION_UP:
+                            case MOTION_EVENT_ACTION_CANCEL:
+                                mConsumedMove = false;
+                                mConsumedDown = false;
+                                break;
+                            default:
+                                break;
+                        }
+                    }
+                }
+            }
+             if (USE_VSYNC) {
                 if (DEBUG_FRAMES) {
                     Log.d(TAG, "Scheduling next frame on vsync.");
                 }
@@ -744,12 +815,14 @@ void doFrame(long frameTimeNanos, int frame,
         final long startNanos;
         final long frameIntervalNanos = vsyncEventData.frameInterval;
         try {
+            mIsDoFrameProcessing = true;
             if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
                 Trace.traceBegin(Trace.TRACE_TAG_VIEW,
                         "Choreographer#doFrame " + vsyncEventData.preferredFrameTimeline().vsyncId);
             }
             FrameData frameData = new FrameData(frameTimeNanos, vsyncEventData);
             synchronized (mLock) {
+                mIsVsyncScheduled = false;
                 if (!mFrameScheduled) {
                     traceMessage("Frame not scheduled");
                     return; // no work to do
@@ -843,6 +916,7 @@ void doFrame(long frameTimeNanos, int frame,
                     + (endNanos - startNanos) * 0.000001f + " ms, latency "
                     + (startNanos - frameTimeNanos) * 0.000001f + " ms.");
         }
+        mIsDoFrameProcessing = false;
     }
 
     void doCallbacks(int callbackType, FrameData frameData, long frameIntervalNanos) {
@@ -935,6 +1009,7 @@ private void scheduleVsyncLocked() {
         try {
             Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#scheduleVsyncLocked");
             mDisplayEventReceiver.scheduleVsync();
+            mIsVsyncScheduled = true;
         } finally {
             Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
diff --git a/core/java/android/view/InputEventReceiver.java b/core/java/android/view/InputEventReceiver.java
index a24c1f95b0c09..71c6cf58c98c8 100644
--- a/core/java/android/view/InputEventReceiver.java
+++ b/core/java/android/view/InputEventReceiver.java
@@ -49,6 +49,7 @@ public abstract class InputEventReceiver {
 
     // Map from InputEvent sequence numbers to dispatcher sequence numbers.
     private final SparseIntArray mSeqMap = new SparseIntArray();
+    Choreographer mChoreographer;
 
     private static native long nativeInit(WeakReference<InputEventReceiver> receiver,
             InputChannel inputChannel, MessageQueue messageQueue);
@@ -267,6 +268,20 @@ private void dispatchInputEvent(int seq, InputEvent event) {
         onInputEvent(event);
     }
 
+    // Called from native code.
+    @SuppressWarnings("unused")
+    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
+        try {
+            if (mChoreographer == null)
+                mChoreographer = Choreographer.getInstance();
+
+            if (mChoreographer != null)
+                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
+        } catch (Exception e) {
+            Log.e(TAG, "cannot invoke setMotionEventInfo.");
+        }
+    }
+
     /**
      * Dump the state of this InputEventReceiver to the writer.
      * @param prefix the prefix (typically whitespace padding) to append in front of each line
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index 0b0bfb1ddbe91..ce9e9a6171209 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -122,6 +122,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
 
     @SuppressWarnings("UnusedDeclaration")
     private static final String TAG = "AbsListView";
+    private static final boolean OPTS_INPUT = true;
+    private static final double MOVE_TOUCH_SLOP = 0.6;
+    private static final double TOUCH_SLOP_MIN = 0.6;
+    private static final double TOUCH_SLOP_MAX = 1.0;
 
     /**
      * Disables the transcript mode.
@@ -808,6 +812,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
      */
     private boolean mIsDetaching;
 
+    private boolean mIsFirstTouchMoveEvent = false;
+    private int mMoveAcceleration;
+    private int mNumTouchMoveEvent = 0;
+
     /**
      * Interface definition for a callback to be invoked when the list or grid
      * has been scrolled.
@@ -992,6 +1000,20 @@ private void initAbsListView() {
         final ViewConfiguration configuration = ViewConfiguration.get(mContext);
         mTouchSlop = configuration.getScaledTouchSlop();
         mVerticalScrollFactor = configuration.getScaledVerticalScrollFactor();
+        if (OPTS_INPUT) {
+            double touchslopprop = MOVE_TOUCH_SLOP;
+            if (touchslopprop > 0) {
+                if (touchslopprop < TOUCH_SLOP_MIN) {
+                    mMoveAcceleration = (int)(mTouchSlop * TOUCH_SLOP_MIN);
+                } else if ((touchslopprop >= TOUCH_SLOP_MIN) && (touchslopprop < TOUCH_SLOP_MAX)){
+                    mMoveAcceleration = (int)(mTouchSlop * touchslopprop);
+                } else {
+                    mMoveAcceleration = mTouchSlop;
+                }
+            } else {
+                mMoveAcceleration = mTouchSlop;
+            }
+        }
         mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
         mOverscrollDistance = configuration.getScaledOverscrollDistance();
@@ -3621,7 +3643,18 @@ private boolean startScrollIfNeeded(int x, int y, MotionEvent vtev) {
         final int deltaY = y - mMotionY;
         final int distance = Math.abs(deltaY);
         final boolean overscroll = mScrollY != 0;
-        if ((overscroll || distance > mTouchSlop) &&
+        boolean isFarEnough = false;
+        if (OPTS_INPUT) {
+            if (mIsFirstTouchMoveEvent) {
+                isFarEnough = distance > mMoveAcceleration;
+            } else {
+                isFarEnough = distance > mTouchSlop;
+            }
+        } else {
+            isFarEnough = distance > mTouchSlop;
+        }
+
+        if ((overscroll || isFarEnough) &&
                 (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
             createScrollingCache();
             if (overscroll) {
@@ -3629,7 +3662,11 @@ private boolean startScrollIfNeeded(int x, int y, MotionEvent vtev) {
                 mMotionCorrection = 0;
             } else {
                 mTouchMode = TOUCH_MODE_SCROLL;
-                mMotionCorrection = deltaY > 0 ? mTouchSlop : -mTouchSlop;
+                if (mIsFirstTouchMoveEvent) {
+                    mMotionCorrection = deltaY > 0 ? mMoveAcceleration : -mMoveAcceleration;
+                } else {
+                    mMotionCorrection = deltaY > 0 ? mTouchSlop : -mTouchSlop;
+                }
             }
             removeCallbacks(mPendingCheckForLongPress);
             setPressed(false);
@@ -3977,21 +4014,38 @@ public boolean onTouchEvent(MotionEvent ev) {
         switch (actionMasked) {
             case MotionEvent.ACTION_DOWN: {
                 onTouchDown(ev);
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
             case MotionEvent.ACTION_MOVE: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent++;
+                    if (mNumTouchMoveEvent == 1) {
+                        mIsFirstTouchMoveEvent = true;
+                    } else {
+                        mIsFirstTouchMoveEvent = false;
+                    }
+                }
                 onTouchMove(ev, vtev);
                 break;
             }
 
             case MotionEvent.ACTION_UP: {
                 onTouchUp(ev);
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
             case MotionEvent.ACTION_CANCEL: {
                 onTouchCancel();
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
@@ -4007,6 +4061,9 @@ public boolean onTouchEvent(MotionEvent ev) {
                     mMotionPosition = motionPosition;
                 }
                 mLastY = y;
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
@@ -4028,6 +4085,9 @@ public boolean onTouchEvent(MotionEvent ev) {
                     mMotionPosition = motionPosition;
                 }
                 mLastY = y;
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
         }
@@ -4632,6 +4692,9 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
 
         switch (actionMasked) {
             case MotionEvent.ACTION_DOWN: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 int touchMode = mTouchMode;
                 if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                     mMotionCorrection = 0;
@@ -4669,6 +4732,14 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
             }
 
             case MotionEvent.ACTION_MOVE: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent++;
+                    if (mNumTouchMoveEvent == 1) {
+                        mIsFirstTouchMoveEvent = true;
+                    } else {
+                        mIsFirstTouchMoveEvent = false;
+                    }
+                }
                 switch (mTouchMode) {
                     case TOUCH_MODE_DOWN:
                         int pointerIndex = ev.findPointerIndex(mActivePointerId);
@@ -4689,6 +4760,9 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
 
             case MotionEvent.ACTION_CANCEL:
             case MotionEvent.ACTION_UP: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 mTouchMode = TOUCH_MODE_REST;
                 mActivePointerId = INVALID_POINTER;
                 recycleVelocityTracker();
@@ -4698,6 +4772,9 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
             }
 
             case MotionEvent.ACTION_POINTER_UP: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 onSecondaryPointerUp(ev);
                 break;
             }
diff --git a/core/jni/android_view_InputEventReceiver.cpp b/core/jni/android_view_InputEventReceiver.cpp
index a7ec38f8b0f6c..6778968f7946c 100644
--- a/core/jni/android_view_InputEventReceiver.cpp
+++ b/core/jni/android_view_InputEventReceiver.cpp
@@ -54,6 +54,7 @@ static struct {
     jmethodID onPointerCaptureEvent;
     jmethodID onDragEvent;
     jmethodID onBatchedInputEventPending;
+    jmethodID dispatchMotionEventInfo;
     jmethodID onTouchModeChanged;
 } gInputEventReceiverClassInfo;
 
@@ -109,6 +110,8 @@ class NativeInputEventReceiver : public LooperCallback {
     bool mBatchedInputEventPending;
     int mFdEvents;
     std::vector<OutboundEvent> mOutboundQueue;
+    int mLastMotionEventType = -1;
+    int mLastTouchMoveNum = -1;
 
     void setFdEvents(int events);
 
@@ -315,10 +318,34 @@ status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,
     bool skipCallbacks = false;
     for (;;) {
         uint32_t seq;
+        int motionEventType = -1;
+        int touchMoveNum = -1;
+        bool flag = false;
+
         InputEvent* inputEvent;
 
         status_t status = mInputConsumer.consume(&mInputEventFactory,
-                consumeBatches, frameTime, &seq, &inputEvent);
+                consumeBatches, frameTime, &seq, &inputEvent,
+                &motionEventType, &touchMoveNum, &flag);
+
+        if (!receiverObj.get()) {
+            receiverObj.reset(jniGetReferent(env, mReceiverWeakGlobal));
+            if (!receiverObj.get()) {
+                ALOGW("channel '%s' ~ Receiver object was finalized "
+                        "without being disposed.", getInputChannelName().c_str());
+                return DEAD_OBJECT;
+            }
+        }
+
+        if (flag && ((mLastMotionEventType != motionEventType) ||
+               (mLastTouchMoveNum != touchMoveNum))) {
+           env->CallVoidMethod(receiverObj.get(),
+               gInputEventReceiverClassInfo.dispatchMotionEventInfo, motionEventType, touchMoveNum);
+           mLastMotionEventType = motionEventType;
+           mLastTouchMoveNum = touchMoveNum;
+           flag = false;
+        }
+
         if (status != OK && status != WOULD_BLOCK) {
             ALOGE("channel '%s' ~ Failed to consume input event.  status=%s(%d)",
                   getInputChannelName().c_str(), statusToString(status).c_str(), status);
@@ -620,7 +647,8 @@ int register_android_view_InputEventReceiver(JNIEnv* env) {
     gInputEventReceiverClassInfo.onBatchedInputEventPending =
             GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, "onBatchedInputEventPending",
                              "(I)V");
-
+    gInputEventReceiverClassInfo.dispatchMotionEventInfo = GetMethodIDOrDie(env,
+            gInputEventReceiverClassInfo.clazz, "dispatchMotionEventInfo", "(II)V");
     return res;
 }
 
